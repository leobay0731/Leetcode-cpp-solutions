/*题目:
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值target的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：
输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：
输入：nums = [3,3], target = 6
输出：[0,1]
*/

//代码1：遍历数组，第一个元素和第二个元素起始位置差1位，保证不使用两次相同的元素
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> arr;
        for(int i = 0; i<nums.size(); i++){
            for(int j = i+1; j<nums.size();j++){
                if(nums[i]+nums[j]==target){
                    arr.push_back(i);
                    arr.push_back(j);
                }
            }
        }
        return arr;
    }
};

//代码2：和1思路一样都是暴力求解，不过不用构建数组
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        for(int i = 0; i<nums.size(); i++){
            for(int j = i+1; j<nums.size();j++){
                if(nums[i]+nums[j]==target){
                    return {i,j};
                }
            }
        }
    return {}; //未找到解时候的兜底，必须有，否则编译器会报错【error: control reaches end of non-void function [-Werror=return-type]】
    }
};

//代码3：运用哈希表
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hashtable; // 只是创建一个空的哈希表，没有任何数据
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]); // 先查补数
            if (it != hashtable.end()) {
                return {it->second, i}; // 找到就返回，不用继续存
            }
            hashtable[nums[i]] = i; // 没找到才把当前元素存进去
        }
    }
}；
